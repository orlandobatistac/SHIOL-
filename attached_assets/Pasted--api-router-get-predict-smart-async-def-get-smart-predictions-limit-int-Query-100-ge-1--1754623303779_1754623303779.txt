@api_router.get("/predict/smart")
async def get_smart_predictions(
    limit: int = Query(100, ge=1, le=100, description="Number of Smart AI predictions to retrieve from database")
):
    """
    Get Smart AI predictions from database with next drawing information.
    Returns latest Smart AI predictions generated by the pipeline.
    """
    try:
        logger.info(f"Received request for {limit} Smart AI predictions from database")

        # Calculate next drawing date and related information
        from src.database import calculate_next_drawing_date
        from datetime import datetime, timedelta

        next_drawing_date = calculate_next_drawing_date()
        current_date = datetime.now()
        next_date = datetime.strptime(next_drawing_date, '%Y-%m-%d')
        days_until_drawing = (next_date - current_date).days

        # Determine if today is drawing day
        is_drawing_day = current_date.weekday() in [0, 2, 5]  # Mon, Wed, Sat

        # Get latest Smart AI predictions from database
        predictions_df = db.get_prediction_history(limit=limit)

        # Convert DataFrame to list of dictionaries
        if not predictions_df.empty:
            predictions_list = predictions_df.to_dict('records')
        else:
            predictions_list = []

        # Convert database records to Smart AI format
        smart_predictions = []
        for i, pred in enumerate(predictions_list):
            # Safely convert all values to ensure JSON serialization
            try:
                # Extract and convert individual numbers safely
                numbers = []
                for num_key in ["n1", "n2", "n3", "n4", "n5"]:
                    num_val = pred.get(num_key, 0)
                    numbers.append(int(num_val) if num_val is not None else 0)

                powerball_val = pred.get("powerball", 0)
                powerball = int(powerball_val) if powerball_val is not None else 0

                score_val = pred.get("score_total", 0.0)
                total_score = float(score_val) if score_val is not None else 0.0

                pred_id = pred.get("id", 0)
                prediction_id = int(pred_id) if pred_id is not None else 0

                smart_pred = {
                    "rank": i + 1,
                    "numbers": numbers,
                    "powerball": powerball,
                    "total_score": total_score,
                    "score_details": {
                        "probability": total_score * 0.4,
                        "diversity": total_score * 0.25,
                        "historical": total_score * 0.2,
                        "risk_adjusted": total_score * 0.15
                    },
                    "model_version": str(pred.get("model_version", "pipeline_v1.0")),
                    "dataset_hash": str(pred.get("dataset_hash", "pipeline_generated")),
                    "prediction_id": prediction_id,
                    "generated_at": str(pred.get("timestamp", "")),
                    "method": "smart_ai_pipeline"
                }
                smart_predictions.append(smart_pred)
            except (ValueError, TypeError, KeyError) as e:
                logger.warning(f"Error converting prediction record {i}: {e}")
                continue

        if not smart_predictions:
            # If no predictions in database, generate some
            logger.warning("No Smart AI predictions found in database, generating new ones...")
            if not predictor:
                raise HTTPException(status_code=503, detail="No predictions available and predictor service not available")

            # Generate a few predictions as fallback
            predictions = predictor.predict_diverse_plays(num_plays=min(limit, 10), save_to_log=True)

            for i, pred in enumerate(predictions):
                # Safely convert numpy types to native Python types
                numbers = [int(x) for x in pred.get("numbers", [])]
                powerball = int(pred.get("powerball", 0))
                total_score = float(pred.get("score_total", 0.0))

                # Convert score_details safely
                score_details = pred.get("score_details", {})
                safe_score_details = {}
                for key, value in score_details.items():
                    if isinstance(value, (np.integer, np.floating)):
                        safe_score_details[key] = float(value)
                    else:
                        safe_score_details[key] = value

                smart_pred = {
                    "rank": i + 1,
                    "numbers": numbers,
                    "powerball": powerball,
                    "total_score": total_score,
                    "score_details": safe_score_details,
                    "model_version": str(pred.get("model_version", "")),
                    "dataset_hash": str(pred.get("dataset_hash", "")),
                    "prediction_id": int(pred.get("log_id", 0)) if pred.get("log_id") else None,
                    "method": "smart_ai_realtime"
                }
                smart_predictions.append(smart_pred)

        # Calculate statistics with safe conversion
        if smart_predictions:
            avg_score = sum(float(p["total_score"]) for p in smart_predictions) / len(smart_predictions)
            best_score = max(float(p["total_score"]) for p in smart_predictions)
        else:
            avg_score = 0.0
            best_score = 0.0

        return {
            "method": "smart_ai_database",
            "smart_predictions": smart_predictions,
            "total_predictions": len(smart_predictions),
            "average_score": float(avg_score),
            "best_score": float(best_score),
            "data_source": "database" if smart_predictions and "pipeline" in smart_predictions[0].get("method", "") else "realtime_generation",
            "predictions_info": {
                "generated_for_drawing": next_drawing_date,
                "drawing_status": "future" if days_until_drawing > 0 else "today" if days_until_drawing == 0 else "past",
                "note": f"Predictions generated for drawing on {next_date.strftime('%B %d, %Y')}",
                "generated_date": datetime.now().strftime('%Y-%m-%d'),
                "generated_formatted": datetime.now().strftime('%B %d, %Y'),
                "generation_time": datetime.now().strftime('%H:%M ET')
            },
            "next_drawing": {
                "date": next_drawing_date,
                "formatted_date": next_date.strftime('%B %d, %Y'),
                "days_until": int(days_until_drawing),
                "is_today": days_until_drawing == 0,
                "is_drawing_day": is_drawing_day,
                "current_date": datetime.now().strftime('%Y-%m-%d'),
                "current_formatted": datetime.now().strftime('%B %d, %Y'),
                "current_day": datetime.now().day,
                "drawing_schedule": {
                    "monday": "Drawing Day",
                    "wednesday": "Drawing Day",
                    "saturday": "Drawing Day",
                    "other_days": "No Drawing"
                }
            },
            "timestamp": datetime.now().isoformat()
        }

    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error retrieving Smart AI predictions: {e}")
        raise HTTPException(status_code=500, detail="Error retrieving Smart AI predictions.")
