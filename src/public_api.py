"""
SHIOL+ Public API Endpoints
===========================

Public endpoints for the new public interface and authentication system.
These endpoints provide public access to predictions and historical data.
"""

from fastapi import APIRouter, HTTPException, Depends, Request, Response
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from typing import Optional, Dict, Any, List
from datetime import datetime, timedelta
from loguru import logger
import json

from src.auth import auth_manager, User
from src.database import get_all_draws, save_prediction_log, get_prediction_history, get_predictions_with_results_comparison, get_grouped_predictions_with_results_comparison
from src.predictor import Predictor
from src.intelligent_generator import DeterministicGenerator
from src.loader import get_data_loader

# Create router for public endpoints
public_router = APIRouter(prefix="/api/v1/public", tags=["public"])
auth_router = APIRouter(prefix="/api/v1/auth", tags=["authentication"])

# Security scheme for protected endpoints
security = HTTPBearer()

def get_next_powerball_drawing() -> Dict[str, Any]:
    """
    Calculate the next Powerball drawing date and time.
    Powerball drawings are on Wednesdays and Saturdays at 10:59 PM ET.
    """
    now = datetime.now()
    
    # Find next Wednesday or Saturday
    days_ahead = 0
    current_weekday = now.weekday()  # Monday = 0, Sunday = 6
    
    if current_weekday < 2:  # Monday or Tuesday
        days_ahead = 2 - current_weekday  # Next Wednesday
    elif current_weekday == 2:  # Wednesday
        # Check if it's before 10:59 PM
        if now.hour < 22 or (now.hour == 22 and now.minute < 59):
            days_ahead = 0  # Today
        else:
            days_ahead = 3  # Next Saturday
    elif current_weekday < 5:  # Thursday or Friday
        days_ahead = 5 - current_weekday  # Next Saturday
    elif current_weekday == 5:  # Saturday
        # Check if it's before 10:59 PM
        if now.hour < 22 or (now.hour == 22 and now.minute < 59):
            days_ahead = 0  # Today
        else:
            days_ahead = 4  # Next Wednesday
    else:  # Sunday
        days_ahead = 2  # Next Wednesday
    
    next_drawing = now + timedelta(days=days_ahead)
    next_drawing = next_drawing.replace(hour=22, minute=59, second=0, microsecond=0)
    
    # Calculate countdown in seconds
    countdown_seconds = int((next_drawing - now).total_seconds())
    
    return {
        "date": next_drawing.strftime("%Y-%m-%d"),
        "time": "22:59:00",
        "timezone": "ET",
        "datetime_iso": next_drawing.isoformat(),
        "countdown_seconds": max(0, countdown_seconds),
        "is_today": days_ahead == 0
    }

@public_router.get("/next-drawing")
async def get_next_drawing_info():
    """
    Get information about the next Powerball drawing and featured prediction.
    Public access - no authentication required.
    """
    try:
        logger.info("Public request for next drawing info")
        
        # Get next drawing info
        next_drawing = get_next_powerball_drawing()
        
        # Get the latest 5 predictions from the database (generated by dashboard)
        try:
            logger.info("Fetching latest predictions from database for public display")
            
            # Get the latest 5 predictions from the database
            predictions_df = get_prediction_history(limit=5)
            
            if predictions_df.empty:
                logger.warning("No predictions found in database")
                # Return empty state if no predictions exist
                featured_prediction = {
                    "predictions": [],
                    "total_predictions": 0,
                    "method": "no_predictions_available",
                    "generated_at": datetime.now().isoformat(),
                    "message": "No predictions available. Please check back later."
                }
            else:
                # Convert database predictions to the expected format
                adaptive_predictions = []
                
                for index, row in predictions_df.iterrows():
                    adaptive_predictions.append({
                        "numbers": [int(row['n1']), int(row['n2']), int(row['n3']), int(row['n4']), int(row['n5'])],
                        "powerball": int(row['powerball']),
                        "confidence_score": round(float(row['score_total']), 3),
                        "method": "adaptive_ai",
                        "generated_at": row['timestamp'],
                        "rank": index + 1,
                        "component_scores": {
                            "probability": round(float(row['score_total']) * 0.4, 3),
                            "diversity": round(float(row['score_total']) * 0.25, 3),
                            "historical": round(float(row['score_total']) * 0.2, 3),
                            "risk_adjusted": round(float(row['score_total']) * 0.15, 3)
                        },
                        "prediction_id": f"db_{row['id']}_{row['timestamp'][:10].replace('-', '')}"
                    })
                
                featured_prediction = {
                    "predictions": adaptive_predictions,
                    "total_predictions": len(adaptive_predictions),
                    "method": "database_adaptive_predictions",
                    "generated_at": datetime.now().isoformat(),
                    "source": "dashboard_generated"
                }
                
                logger.info(f"Successfully retrieved {len(adaptive_predictions)} predictions from database")
            
        except Exception as e:
            logger.error(f"Error generating featured prediction: {e}")
            # Fallback prediction if generation fails
            featured_prediction = {
                "numbers": [7, 14, 21, 35, 42],
                "powerball": 18,
                "confidence_score": 0.75,
                "method": "fallback",
                "generated_at": datetime.now().isoformat(),
                "note": "Fallback prediction - system temporarily unavailable"
            }
        
        return {
            "next_drawing": next_drawing,
            "featured_prediction": featured_prediction,
            "system_status": "operational",
            "last_updated": datetime.now().isoformat()
        }
        
    except Exception as e:
        logger.error(f"Error in next drawing endpoint: {e}")
        raise HTTPException(status_code=500, detail="Failed to get next drawing information")

@public_router.get("/recent-results")
async def get_recent_results(limit: int = 30):
    """
    Get recent official Powerball results.
    Public access with simplified historical data (no prediction comparisons for now).
    
    Args:
        limit: Number of recent results to return (max 50)
    """
    try:
        logger.info(f"Public request for recent results (limit: {limit})")
        
        # Validate limit
        if limit > 50:
            limit = 50
        elif limit < 1:
            limit = 1
        
        # Get historical data from database
        historical_data = get_all_draws()
        
        if historical_data.empty:
            return {
                "results": [],
                "count": 0,
                "message": "No historical data available"
            }
        
        # Sort by date descending and limit results
        recent_draws = historical_data.sort_values('draw_date', ascending=False).head(limit)
        
        results = []
        for _, row in recent_draws.iterrows():
            # Format jackpot amount if available
            jackpot_amount = "Not available"
            if 'jackpot' in row and row['jackpot']:
                try:
                    jackpot_value = float(row['jackpot'])
                    if jackpot_value > 0:
                        jackpot_amount = f"${jackpot_value:,.0f}"
                except:
                    pass
            
            result = {
                "draw_date": row['draw_date'].strftime("%Y-%m-%d"),
                "winning_numbers": [
                    int(row['n1']), int(row['n2']), int(row['n3']), 
                    int(row['n4']), int(row['n5'])
                ],
                "powerball": int(row['pb']),
                "jackpot_amount": jackpot_amount,
                "multiplier": int(row.get('multiplier', 1)) if 'multiplier' in row else None
            }
            
            # Note: Prediction comparison removed for initial implementation
            # as per user feedback - focusing on official results only
            
            results.append(result)
        
        return {
            "results": results,
            "count": len(results),
            "total_available": len(historical_data),
            "last_updated": datetime.now().isoformat()
        }
        
    except Exception as e:
        logger.error(f"Error in recent results endpoint: {e}")
        raise HTTPException(status_code=500, detail="Failed to get recent results")
@public_router.get("/predictions-performance")
async def get_predictions_performance(limit: int = 10):
    """
    Get AI predictions with comparison to official results and prize calculations.
    Shows HYBRID GROUPED format: 5 ADAPTIVE predictions per official result.
    
    Args:
        limit: Number of recent official results to return (max 20)
    """
    try:
        logger.info(f"Public request for predictions performance - HYBRID GROUPED format (limit: {limit})")
        
        # Validate limit
        if limit > 20:
            limit = 20
        elif limit < 1:
            limit = 1
        
        # Get grouped predictions with results comparison and prize calculations
        grouped_comparisons = get_grouped_predictions_with_results_comparison(limit_groups=limit)
        
        if not grouped_comparisons:
            return {
                "prediction_groups": [],
                "count": 0,
                "total_prize_won": 0,
                "message": "No prediction comparisons available yet"
            }
        
        # Format results for HYBRID display with 5 predictions per official result
        formatted_groups = []
        total_prize_won = 0
        total_predictions_with_prizes = 0
        total_predictions_count = 0
        
        for group in grouped_comparisons:
            # Extract data from the actual structure returned by the database function
            draw_date = group['draw_date']
            winning_numbers = group['winning_numbers']
            winning_powerball = group['winning_powerball']
            predictions = group['predictions']
            group_summary = group['summary']
            
            # Format official result
            formatted_official = {
                "draw_date": draw_date,
                "winning_numbers": winning_numbers,
                "winning_powerball": winning_powerball,
                "jackpot_amount": "Not available"  # Could be enhanced later
            }
            
            # Format each prediction in the group (they're already formatted by the database function)
            formatted_predictions = []
            group_prize_total = 0
            
            for pred in predictions:
                # The predictions are already well-formatted by the database function
                prize_amount = pred.get('prize_amount', 0)
                group_prize_total += prize_amount
                total_prize_won += prize_amount
                total_predictions_count += 1
                
                if prize_amount > 0:
                    total_predictions_with_prizes += 1
                
                # Create the formatted prediction using the existing data
                formatted_prediction = {
                    "prediction_id": f"pred_{pred['prediction_date']}_{pred['prediction_id']}",
                    "prediction_date": pred['prediction_date'],
                    "prediction_numbers": pred['prediction_numbers'],
                    "prediction_powerball": pred['prediction_powerball'],
                    "number_matches": pred['number_matches'],
                    "powerball_match": pred['powerball_match'],
                    "total_matches": pred['total_matches'],
                    "powerball_matches": 1 if pred['powerball_match'] else 0,
                    "prize_amount": prize_amount,
                    "prize_display": pred['prize_display'],
                    "prize_description": pred['prize_description'],
                    "method": "adaptive_ai",
                    "has_prize": pred['has_prize'],
                    "play_number": pred['play_number']
                }
                
                formatted_predictions.append(formatted_prediction)
            
            # Create group summary using the data from database function
            formatted_group_summary = {
                "total_predictions": group_summary['total_predictions'],
                "predictions_with_prizes": group_summary['predictions_with_prizes'],
                "group_prize_total": group_summary['total_prize'],
                "group_prize_display": group_summary['total_prize_display'],
                "best_result": group_summary['best_result'],
                "average_matches": group_summary['avg_matches'],
                "group_win_rate": group_summary['win_rate_percentage']
            }
            
            # Create the hybrid group
            formatted_group = {
                "group_id": f"group_{draw_date}",
                "official_result": formatted_official,
                "predictions": formatted_predictions,
                "group_summary": formatted_group_summary
            }
            
            formatted_groups.append(formatted_group)
        
        # Calculate overall summary statistics for marketing appeal
        overall_win_rate = (total_predictions_with_prizes / total_predictions_count) * 100 if total_predictions_count > 0 else 0
        
        return {
            "prediction_groups": formatted_groups,
            "count": len(formatted_groups),
            "format": "hybrid_grouped",
            "summary": {
                "total_official_results": len(formatted_groups),
                "total_predictions": total_predictions_count,
                "total_prize_won": total_prize_won,
                "total_prize_display": f"${total_prize_won:,.2f}",
                "predictions_with_prizes": total_predictions_with_prizes,
                "overall_win_rate_percentage": round(overall_win_rate, 1),
                "average_prize_per_prediction": round(total_prize_won / total_predictions_count, 2) if total_predictions_count > 0 else 0,
                "groups_with_prizes": len([g for g in formatted_groups if g['group_summary']['predictions_with_prizes'] > 0])
            },
            "system_info": {
                "method": "ADAPTIVE AI Predictions - Hybrid Grouped Format",
                "predictions_per_result": 5,
                "tracking_period": "Historical Performance",
                "last_updated": datetime.now().isoformat()
            }
        }
        
    except Exception as e:
        logger.error(f"Error in predictions performance endpoint: {e}")
        raise HTTPException(status_code=500, detail="Failed to get predictions performance data")

# Authentication endpoints
@auth_router.post("/login")
async def login(request: Request, response: Response):
    """
    Authenticate user with username and password.
    Returns session token for accessing protected areas.
    """
    try:
        body = await request.json()
        username = body.get('username')
        password = body.get('password')
        
        if not username or not password:
            raise HTTPException(status_code=400, detail="Username and password required")
        
        # Get client info
        client_ip = request.client.host
        user_agent = request.headers.get('user-agent')
        
        # Authenticate user
        user = auth_manager.authenticate_user(username, password)
        if not user:
            logger.warning(f"Failed login attempt for username: {username} from IP: {client_ip}")
            raise HTTPException(status_code=401, detail="Invalid credentials")
        
        # Create session
        session_token = auth_manager.create_session(
            user=user,
            ip_address=client_ip,
            user_agent=user_agent,
            expires_hours=24
        )
        
        if not session_token:
            raise HTTPException(status_code=500, detail="Failed to create session")
        
        logger.info(f"User '{username}' logged in successfully from IP: {client_ip}")
        
        return {
            "success": True,
            "session_token": session_token,
            "user": {
                "username": user.username,
                "role": user.role,
                "email": user.email
            },
            "expires_in_hours": 24,
            "message": "Login successful"
        }
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error during login: {e}")
        raise HTTPException(status_code=500, detail="Login failed")

@auth_router.post("/logout")
async def logout(credentials: HTTPAuthorizationCredentials = Depends(security)):
    """
    Logout user by invalidating session token.
    """
    try:
        session_token = credentials.credentials
        
        success = auth_manager.logout_session(session_token)
        
        if success:
            return {"success": True, "message": "Logged out successfully"}
        else:
            return {"success": False, "message": "Session not found"}
            
    except Exception as e:
        logger.error(f"Error during logout: {e}")
        raise HTTPException(status_code=500, detail="Logout failed")

@auth_router.get("/verify")
async def verify_session(credentials: HTTPAuthorizationCredentials = Depends(security)):
    """
    Verify if session token is valid and return user info.
    """
    try:
        session_token = credentials.credentials
        
        user = auth_manager.verify_session(session_token)
        
        if not user:
            raise HTTPException(status_code=401, detail="Invalid or expired session")
        
        return {
            "valid": True,
            "user": {
                "username": user.username,
                "role": user.role,
                "email": user.email,
                "last_login": user.last_login.isoformat() if user.last_login else None
            }
        }
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error verifying session: {e}")
        raise HTTPException(status_code=500, detail="Session verification failed")

# Dependency for protected endpoints
async def get_current_user(credentials: HTTPAuthorizationCredentials = Depends(security)) -> User:
    """
    Dependency to get current authenticated user from session token.
    """
    session_token = credentials.credentials
    user = auth_manager.verify_session(session_token)
    
    if not user:
        raise HTTPException(status_code=401, detail="Invalid or expired session")
    
    return user

# Protected endpoint example (for dashboard access verification)
@auth_router.get("/dashboard-access")
async def verify_dashboard_access(current_user: User = Depends(get_current_user)):
    """
    Verify user has access to dashboard.
    This endpoint can be called by frontend to check access before showing dashboard.
    """
    return {
        "access_granted": True,
        "user": {
            "username": current_user.username,
            "role": current_user.role
        },
        "dashboard_url": "/dashboard"
    }